#' @title Simulate Tree Structured Counts
#'
#' @description
#' Simulate a tree structured matrix of counts according to a Poisson-lognormal
#' model, with the log parameter of the poisson following a Brownian Motion (BM)
#' on the tree with noise.
#'
#' @details
#' For each gene, the log-lambda parameter evolves like a BM on the tree,
#' with an extra independent variance noise that can depend on the species.
#' Each gene has its own tree variance for the BM.
#' Each gene and each species has its own mean.
#' The counts for each gene and each species are then obtained as a Poisson draw
#' with a different lambda parameter, as generated by the BM.
#' 
#' @param tree A phylogenetic tree with n tips.
#' @param log_means a matrix with the number of genes p rows and the number of
#' species n columns. Column names should match the tree taxa names.
#' @param log_variance_phylo a vector of length p of phylogenetic variances for 
#' the BM in the log space for each gene.
#' @param log_variance_sample a matrix of size p x n of environemental variances
#' for individual variations in the log space, for each gene and species.
#' Column names should match the tree taxa names.
#' 
#' @return A list, with:
#' \describe{
#' \item{log_lambda}{the p x n matrix of log-lambda simulated by the BM on the tree.}
#' \item{counts}{the p x n matrix of counts with corresponding Poisson draws.}
#' }
#' 
#' @keywords internal
#' 
simulatePhyloPoissonLogNormal <- function(tree, log_means, log_variance_phylo, log_variance_sample, model_process = "BM", selection.strength = 0) {
  
  ## Check for packages
  if (!requireNamespace("ape", quietly = TRUE) || !requireNamespace("phylolm", quietly = TRUE)) {
    stop("Packages 'ape' and 'phylolm' are needed for tree simulations.", call. = FALSE)
  }
  
  ## Check means
  checkParamMatrix(log_means, "log means", tree)
  checkParamMatrix(log_variance_sample, "log variance sample", tree)
  
  N <- length(tree$tip.label)
  P <- nrow(log_means)
  
  ## Check Dimension
  if (nrow(log_variance_sample) != P || length(log_variance_phylo) != P) {
    stop("`log_means` and `log_variance_sample should have as many rows as the length of `log_variance_phylo`.")
  }
  
  ## Phylogenetic simulation of log(lambda)
  # resids <- mvMORPH::mvSIM(tree = tree,
  #                          nsim = P,
  #                          error = 0,
  #                          model = model_process,
  #                          param = params_process)
  
  # resids <- ape::rTraitMult(phy = tree,
  #                           model = function(x, l) return(x + rnorm(length(x), 0, sqrt(l))),
  #                           p = P,
  #                           root.value = rep(0.0, P))
  
  resids <- phylolm::rTrait(n = P,
                            phy = tree,
                            model = model_process,
                            parameters = list(sigma2 = 1, ancestral.state = 0, optimal.value = 0, alpha = selection.strength),
                            plot.tree = FALSE)
  
  # V <- ape::vcv(tree)
  # resids <- matrix(rnorm(N * P, mean = 0, sd = 1), nrow = N)
  # resids <- t(chol(V)) %*% resids
  
  log_sd_phylo <- scale_variance_process(log_variance_phylo, tree, model_process, selection.strength)
  
  ## phylo variances
  resids <- resids * log_sd_phylo
  
  ## resid variances
  resids <- t(resids) + matrix(rnorm(N * P, mean = 0, sd = sqrt(log_variance_sample)), ncol = N)
  
  ## Expectations
  log_lambda <- resids + log_means
  
  ## Poisson
  counts <- matrix(rpois_robust(N * P, exp(log_lambda)), ncol = N)
  
  ## Names
  colnames(counts) <- colnames(log_lambda) <- tree$tip.label
  
  return(list(log_lambda = log_lambda,
              counts = counts))
}

#' @title Robust rpois
#'
#' @description
#' When \code{lambda < 0.999 * .Machine$integer.max}, this function uses the vanilla \code{\link[stats]{rpois}} function.
#' When lambda is larger, it uses the Gaussian approximation.
#'
#' @details
#' Idea comes from: https://stackoverflow.com/questions/23770926/rpois-generates-na-with-large-means-lambda-in-r
#' 
#' @param n number of random values to return.
#' @param lambda vector of (non-negative) means. Must be of length n.
#' 
#' @return A vector of n random draws.
#' 
#' @keywords internal
#' 
rpois_robust <- function(n, lambda) {
  if (n != length(lambda)) stop("`lambda` must be of length `n` in `rpois_robust`.")
  
  too_large <- lambda >= 0.999 * .Machine$integer.max
  N_too_large <- sum(too_large)
  N_not_too_large <- n - N_too_large
  
  sim <- rep(NA, n)
  sim[!too_large] <- rpois(N_not_too_large, lambda[!too_large])
  sim[too_large] <- round(rnorm(N_too_large, mean = lambda, sd = sqrt(lambda)))
  
  return(sim)
}

#' @title Check Matrix Parameter
#'
#' @description
#' Check that the parameters are compatible with the tree. Throws an error if not.
#' 
#' @param x matrix of parameters being tested.
#' @param name name of the parameter.
#' @param tree A phylogenetic tree with n tips.
#' 
#' @keywords internal
#' 
checkParamMatrix <- function(x, name, tree) {
  N <- length(tree$tip.label)
  
  if (ncol(x) != N) {
    stop(paste0("`", name, "` should have as many columns as the number of taxa in the tree."))
  }
  if ((is.null(tree$tip.label) || is.null(colnames(x)))){
    warning(paste0("`", name, "` and/or the tips of the phylogeny are not named. Could not check for consistency : please make sure that you gave them in the right order."))
  } else {
    if (!all(tree$tip.label == colnames(x))){
      correspondances <- match(tree$tip.label, colnames(x))
      if (length(unique(correspondances)) != length(tree$tip.label)){
        stop(paste0("`", name, "` names do not match the tip labels."))
      }
      warning(paste0("`", name, "` was not sorted in the correct order, when compared with the tips label. I am re-ordering it."))
      x <- x[, correspondances, drop = FALSE]
    }
  }
}

#' @title Check Vector Parameter
#'
#' @description
#' Check that the parameters are compatible with the tree. Throws an error if not.
#' 
#' @param x vector of parameters being tested.
#' @param name name of the parameter.
#' @param tree A phylogenetic tree with n tips.
#' 
#' @keywords internal
#' 
checkParamVector <- function(x, name, tree) {
  N <- length(tree$tip.label)
  
  if (length(x) != N) {
    stop(paste0("`", name, "` should have the same length as the number of taxa in the tree."))
  }
  if ((is.null(tree$tip.label) || is.null(names(x)))){
    warning(paste0("`", name, "` and/or the tips of the phylogeny are not named. Could not check for consistency : please make sure that you gave them in the right order."))
  } else {
    if (!all(tree$tip.label == names(x))){
      correspondances <- match(tree$tip.label, names(x))
      if (length(unique(correspondances)) != length(tree$tip.label)){
        stop(paste0("`", name, "` names do not match the tip labels."))
      }
      warning(paste0("`", name, "` was not sorted in the correct order, when compared with the tips label. I am re-ordering it."))
      x <- x[correspondances]
    }
  }
}

#' @title Check Species
#'
#' @description
#' Check that the parameters are compatible with the tree. Throws an error if not.
#' 
#' @inheritParams checkParamVector
#' 
#' @keywords internal
#' 
checkSpecies <- function(x, name, tree, tol, check.id.species) {
  checkParamVector(x, name, tree)
  if (check.id.species) {
    related_matrices <- sapply(x, function(i) i == x)
    if (!all(related_matrices == (ape::cophenetic.phylo(tree) <= tol))) {
      stop("The provided species do not match with the tree branch lengths. Please check the 'id.species' vector. If you want to skip this check, re-lauch with option 'check.id.species=FALSE'.")
    }
  }
}

#' @title Add replicates to a tree
#'
#' @description
#' Utility function to add replicates to a tree, as tips with zero length branches.
#' 
#' @param tree A phylogenetic tree with n tips.
#' @param r the number of replicates too add at each species.
#' 
#' @return A phylogenetic tree with n * r tips, and clusters of tips with zero branch lengths.
#' 
#' @keywords internal
#' 
add_replicates <- function(tree, r) {
  tree_rep <- tree
  # Add replicates
  for (tip_label in tree$tip.label) {
    for (rep in 1:r) {
      tree_rep <- phytools::bind.tip(tree_rep, tip.label = paste0(tip_label, "_", rep),
                                     where = which(tree_rep$tip.label == tip_label))
    }
  }
  # Remove original tips
  tree_rep <- ape::drop.tip(tree_rep, tree$tip.label)
  return(tree_rep)
}

#' @title Compute log means and variances
#'
#' @description 
#' From the parameters of a negative binomial (count_means and count_dispertions),
#' compute the parameters of a phylogenetic Poisson log-normal with the
#' same expectations and variances.
#' 
#' @param count_means a matrix with the number of genes p rows and the number of
#' species n columns. Column names should match the tree taxa names.
#' @param count_dispertions a matrix of size p x n, for each gene and species.
#' Column names should match the tree taxa names.
#' 
#' @return A list, with:
#' \describe{
#' \item{log_means}{the p x n matrix of log-means for Poisson-lognormal simulations.}
#' \item{log_variance_phylo}{the p vector of phylogenetic log-variances for Poisson-lognormal simulations.}
#' \item{log_variance_sample}{the p x n matrix of environemental log-variances for Poisson-lognormal simulations.}
#' }
#' 
#' @keywords internal
#' 
get_poisson_log_normal_parameters <- function(count_means, count_dispertions, prop.var.tree) {
  N <- ncol(count_means)
  P <- nrow(count_means)
  
  ## Check Dimension
  if (nrow(count_dispertions) != P || ncol(count_dispertions) != N) {
    stop("`count_means` and `count_dispertions` should have the same dimensions.")
  }
  
  ## Check Proportion
  if (prop.var.tree > 1.0 || prop.var.tree < 0.0) {
    stop("`prop.var.tree` should be between 0 and 1.")
  }
  
  ## Parameters of the PLN
  params_PLN <- NB_to_PLN(count_means, count_dispertions)
  log_means <- params_PLN$log_means_pln
  log_variances_all <- params_PLN$log_variances_pln
  
  ## Phylo variances
  ## Check for packages
  if (!requireNamespace("matrixStats", quietly = TRUE)) {
    log_variance_phylo <- apply(log_variances_all, 1, min) * prop.var.tree
  } else {
    log_variance_phylo <- matrixStats::rowMins(log_variances_all) * prop.var.tree
  }
  
  ## Sample variances
  log_variance_sample <- log_variances_all - log_variance_phylo %*% t(rep(1, N))
  
  return(list(log_means = log_means,
              log_variance_phylo = log_variance_phylo,
              log_variance_sample = log_variance_sample))
}

#' @title Negative Binomial to Poisson Log-Normal
#'
#' @description 
#' From the parameters of a negative binomial (mean and dispertion),
#' compute the parameters of a Poisson log-normal with the
#' same expectation and variance.
#' 
#' @param mean mean of the negative binomial.
#' @param dispertion dispersion of the negative binomial.
#' 
#' @return A list, with:
#' \describe{
#' \item{log_means_pln}{Mean of the Poisson log normal in the log space.}
#' \item{log_variances_pln}{Variance of the Poisson log normal in the log space.}
#' }
#' 
#' @keywords internal
#' 
NB_to_PLN <- function(mean, dispersion) {
  ## Variance in log space
  log_variances_pln <- log(1 + dispersion)
  ## Mean in log space
  log_means_pln <- log(mean) - 0.5 * log_variances_pln
  
  return(list(log_means_pln = log_means_pln,
              log_variances_pln = log_variances_pln))
}

#' @title Simulate the Data using the tree
#'
#' @description 
#' Use the Phylogenetic Poisson Log Normal model to simulate the data.
#' 
#' @inheritParams generateSyntheticData 
#' @inheritParams simulateData
#' 
#' @return Z a matrix with the data
#' 
#' @keywords internal
#' 
simulateDataPhylo <- function(count_means,
                              count_dispertions,
                              tree, prop.var.tree,
                              model_process = "BM", selection.strength = 0) {
  ### Initialize data matrix
  colnames(count_means) <- colnames(count_dispertions) <- tree$tip.label
  
  ### Get Equivalent Phylogenetic Poisson log-normal parameters
  params_poisson_lognormal <- get_poisson_log_normal_parameters(count_means, count_dispertions, prop.var.tree)
  
  ### Simulate Data
  res_sim <- simulatePhyloPoissonLogNormal(tree,
                                           params_poisson_lognormal$log_means,
                                           params_poisson_lognormal$log_variance_phylo,
                                           params_poisson_lognormal$log_variance_sample,
                                           model_process = model_process,
                                           selection.strength = selection.strength)
  return(res_sim$counts)
}

#' @title Scale the variances
#'
#' @description 
#' Scale the variances of the process simulation so that they are equel to log_variance_phylo.
#' 
#' @inheritParams generateSyntheticData 
#' @inheritParams simulateData
#' 
#' @return A matrix N * P of factors to multiply the simulated phylogenetic residuals.
#' 
#' @keywords internal
#' 
scale_variance_process <- function(log_variance_phylo, tree, model_process, selection.strength) {
  fac <- get_model_factor(model_process, selection.strength, tree)
  return(fac %*% t(sqrt(log_variance_phylo)))
}

#' @title Get the scaling factor
#'
#' @description 
#' Get the scaling factors.
#' 
#' @inheritParams generateSyntheticData 
#' 
#' @return A vector N of factors.
#' 
#' @keywords internal
#' 
get_model_factor <- function(model_process, selection.strength, tree) {
  heights <- ape::node.depth.edgelength(tree)[1:length(tree$tip.label)]
  if (model_process == "BM" || selection.strength == 0) {
    return(sqrt(1 / heights))
  } else if (model_process == "OU") {
    return(sqrt(1 / expm1(-2 * selection.strength * heights) * (-2 * selection.strength)))
  } else {
    stop("Process not yet implemented.")
  }
}

#' @title Multiplying factor for Non central Fisher
#'
#' @description 
#' Under the alternative hypothesis, multiplying factor for the non-central Fisher
#' distribution parameter, compared to the case where samples are iid and of equal size.
#' If the factor is above 1.0, then the problem is "easier" than this the null problem.
#' If it is below 1.0, then the problem is "harder".
#' 
#' @param tree A phylogenetic tree. If \code{NULL}, samples are assumed to be iid.
#' @param id.condition A named vector giving the state of each tip (sample).
#' 
#' @return The multiplying factor.
#' 
#' @keywords internal
#' 
deltaFisher <- function(tree, id.condition) {
  if (is.null(tree)) {
    n <- length(id.condition)
    Vinv <- diag(1, n)
  } else {
    # Check vector order
    checkParamVector(id.condition, "id.condition", tree)
    # tree
    n <- length(tree$tip.label)
    Vinv <- solve(ape::vcv(tree))
  }
  # Intercept
  X <- rep(1, n)
  # Model matrix
  Z <- stats::model.matrix(~factor(id.condition))[, -1, drop = FALSE]
  deltaF <- (diag(1, n) -  X %*% solve(t(X) %*% Vinv %*% X) %*% t(X) %*% Vinv) %*% Z
  deltaF <- t(deltaF) %*% Vinv %*% deltaF
  return(unname(as.vector(deltaF)) / n * 4)
}

#' @title Multiplying factor for Non central Student
#'
#' @description 
#' Under the alternative hypothesis, multiplying factor for the non-central Student
#' distribution parameter, compared to the case where samples are iid and of equal size.
#' If the factor is above 1.0, then the problem is "easier" than this the null problem.
#' If it is below 1.0, then the problem is "harder".
#' WARNING: This can be identified to the Student distribution only when \code{id.condition} has exactelly two factors.
#' Otherwise, this is just the square root of the non-central Fisher factor (see \code{\link{deltaFisher}}).
#' 
#' @param tree A phylogenetic tree. If \code{NULL}, samples are assumed to be iid.
#' @param id.condition A named vector giving the state of each tip (sample).
#' 
#' @return The multiplying factor.
#' 
#' @keywords internal
#' 
deltaStudent <- function(tree, id.condition) {
  return(sqrt(deltaFisher(tree, id.condition)))
}
